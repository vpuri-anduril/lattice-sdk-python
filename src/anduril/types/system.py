# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel
from ..core.serialization import FieldMetadata


class System(UniversalBaseModel):
    """
    System Principal representing some autonomous system.
    """

    service_name: typing_extensions.Annotated[typing.Optional[str], FieldMetadata(alias="serviceName")] = (
        pydantic.Field(default=None)
    )
    """
    Name of the service associated with this System.
    """

    entity_id: typing_extensions.Annotated[typing.Optional[str], FieldMetadata(alias="entityId")] = pydantic.Field(
        default=None
    )
    """
    The Entity ID of the System.
    """

    manages_own_scheduling: typing_extensions.Annotated[
        typing.Optional[bool], FieldMetadata(alias="managesOwnScheduling")
    ] = pydantic.Field(default=None)
    """
    Whether the System Principal (for example, an Asset) can own scheduling.
     This means we bypass manager-owned scheduling and defer to the system
     Principal to handle scheduling and give us status updates for the Task.
     Regardless of the value defined by the client, the Task Manager will
     determine and set this value appropriately.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow
